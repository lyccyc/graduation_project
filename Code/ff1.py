# -*- coding: utf-8 -*-
"""id_encry-Copy1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sVcn4aR-SRozI0FP-MBvxBXeIyh_prNP
"""

import math
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from Crypto.Random import get_random_bytes
import pandas as pd
import hashlib

# # 讀取 16bytes 的密鑰
# f = open('key_for_16_bit.txt')
# key = f.read()
# f.close()

key = "2DE79D232DF5585D68CE47882AE256D6"

def CIPH(key, X):
    """
    輸入:
    key: 加密密鑰，類型為bytes，長度應為16位元組。
    X: 要加密的資料，類型為bytes，長度應為16位元組。
    """
    # 使用 PyCtyptodome 程式庫實作
    # 選擇 Cipher-block chaining (CBC)模態
    cipher = AES.new(key, AES.MODE_CBC, iv=bytes(16))
    iv = cipher.iv
    # 加密 X
    ciphertext = cipher.encrypt(X)
    return ciphertext

def PRF(key, X):
    """
    輸入:
    key: 加密密鑰，類型為bytes，長度應為16位元組。
    X: 要進行處理的數據，類型為bytes，長度應為16位元組的整數倍。
    """
    # 計算X可以分成多少個16位元組的塊
    m = int(len(X) / 16)
    zero = 0
    # 初始化Y為16位元組的0值
    Y_0 = zero.to_bytes(16, 'big')
    # 將X分解為多個16位元組的塊
    X_list = [X[i*16 : (i+1)*16] for i in range(m)]
    for i in range(m):
        if i == 0:
            # 將Y從 bytes 轉換為整數
            Y_0 = int.from_bytes(Y_0, 'big')
            # 將當前塊X從 bytes 轉換為整數
            X = int.from_bytes(X_list[i], 'big')
            data = Y_0 ^ X  # 對Y和X進行XOR運算
            # 將結果由整數轉換回 bytes
            data = data.to_bytes(16, 'big')
            # 使用密鑰對數據進行加密
            Y = CIPH(key, data)
        # 將Y從 bytes 轉換為整數
        Y = int.from_bytes(Y, 'big')
        # 將當前塊X從 bytes 轉換為整數
        X = int.from_bytes(X_list[i], 'big')
        # 與前一密文塊進行XOR運算
        data = Y ^ X
        # 將結果轉換回 bytes
        data = data.to_bytes(16, 'big')
        Y = CIPH(key, data)
    return Y

def NUM_radix(n, radix):
    """
    將數字n轉換成給定基數radix的字串表示形式。
    """

    if n == 0:
        return 0
    a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F']
    b = []
    while n > 0:
        b.append(a[n % radix])
        n = n // radix
    # 反轉列表以得到正確的順序
    b.reverse()
    return int(''.join(map(str, b)))

def str_radix_m(n, m, radix):
    """
    給定一個數字n和長度m，將數字轉換為基數radix的字串表示，確保字串長度為m。
    """
    X = [0] * m
    for i in range(m - 1, -1, -1):
        # 獲取當前基數的餘數
        X[i] = n % radix
        # 更新數字為商
        n = n // radix
    return ''.join(map(str, X))

def FF1(plaintext, radix, key, tweak):
    """
    輸入:
    plaintext: 待加密的文本字串。
    radix: 基數，用於確定加密的基數系統。
    key: 加密密鑰，類型為bytes，長度應為16位元組。
    tweak: 用於加密調整的數據，類型為bytes。
    """
    # n為plaintext字串的字元長度
    n = len(plaintext)
    # 回傳小於等於x的最大整數
    u = math.floor(n / 2)
    v = n - u
    A = plaintext[:u]
    B = plaintext[u:]

    # math.ceil(x)回傳小於等於x的最大整數
    b = math.ceil((math.ceil(math.log2(radix) * v)) / 8)
    d = 4 * math.ceil(b / 4) + 4
    t = len(tweak)

    # || 表示 concatenation
    # P = [1]^1 || [2]^1 || [1]^1 ||[radix]^3 || [10]^1 || [u mod 256]^1 || [n]^4 || [t]^4
    P = bytes([1, 2, 1]) + radix.to_bytes(3, 'big') + bytes([10, u%256]) + n.to_bytes(4, 'big') + t.to_bytes(4, 'big')

    for i in range(10):
        # Q = tweak || [0]^(-t-b-1) mod 16 || [i]^1 ||[NUM_radix(B)]^b
        Q = tweak + (0).to_bytes((-t - b - 1) % 16, 'big') + i.to_bytes(1, 'big') + NUM_radix(int(B), radix).to_bytes(b, 'big')
        R = PRF(key, P + Q)
        y = int.from_bytes(R[1], 'big')
        y = NUM_radix(y, 2)

        if i % 2 == 0:
            m = u
        else:
            m = v

        c = (NUM_radix(int(A), radix) + y) % radix ** m
        # 將整數 c 轉換為長度為m的字串
        C = str_radix_m(c, m, radix)
        A = B
        B = C

    return str(A) + str(B)

def FF1_decrypt(ciphertext, radix, key, tweak):
    """
    輸入:
    ciphertext: 待解密的文本字串。
    radix: 基數，用於確定解密的基數系統。
    key: 解密密鑰，類型為bytes，長度應為16位元組。
    tweak: 用於解密調整的數據，類型為bytes。
    輸出:
    返回解密和處理後的文本。
    """
    n = len(ciphertext)
    u = math.floor(n / 2)
    v = n - u
    A = ciphertext[:u]
    B = ciphertext[u:]

    b = math.ceil((math.ceil(math.log2(radix) * v)) / 8)
    d = 4 * math.ceil(b / 4) + 4
    tweak = tweak.to_bytes(2, 'big')
    t = len(tweak)

    P = bytes([1, 2, 1]) + radix.to_bytes(3, 'big') + bytes([10, u%256]) + n.to_bytes(4, 'big') + t.to_bytes(2, 'big')

    for i in range(9, -1, -1):
        if i % 2 == 0:
            m = u
        else:
            m = v

        C = A
        A = B
        B = C

        Q = tweak + (0).to_bytes((-t - b - 1) % 16, 'big') + i.to_bytes(1, 'big') + NUM_radix(int(B), radix).to_bytes(b, 'big')
        R = PRF(key, P + Q)
        y = int.from_bytes(R, 'big')
        y = NUM_radix(y, 2)

        c = (NUM_radix(int(A), radix) - y) % radix ** m
        A = str_radix_m(c, m, radix)

    return A + B

def generate_tweak(index):
    return hashlib.sha256(str(index).encode()).hexdigest()[:14].upper()

def adject_position(arr):
    n = len(arr)
    even_index = 1
    odd_index = 0
    result = [None] * n

    for i in arr:
        num = int(i[0:2])
        if even_index >= n:
            result[odd_index] = i
            odd_index += 2
            continue
        elif odd_index >= n:
            result[even_index] = i
            even_index += 2
            continue
        else:
            if num >= 50:
                if even_index < n:
                    result[even_index] = i
                    even_index += 2
            else:
                if odd_index < n:
                    result[odd_index] = i
                    odd_index += 2
    return result

def adject_value(arr):
    n = len(arr)
    result = [None] * n

    for i in arr.index:
        tmp = int(arr[i][0:2])
        if tmp >= 50:
            tmp = tmp - 50
        if tmp < 10:
            if tmp < 1:
                tmp = str(0) + str(0)
            else:
                tmp = str(0) + str(tmp)
        else:
            tmp = str(tmp)
        result[i] = tmp + arr[i][2:]
    return result

def number_to_IDN(arr):
    n = len(arr)
    result = [None] * n

    for i in arr.index:
        result_ = ''
        sex = '1'
        tmp = int(arr[i][0:2])
        if tmp >= 25:
            tmp = tmp - 25
            sex = '2'
        if tmp == 24:
            tmp = 25
        tmp += 65
        tmp = chr(tmp)
        result_ = result_ + result_.join(tmp) + result_.join(sex) + result_.join(arr[i][2:])
        result[i] = result_
    return result

def IDN_to_number(arr):
    n = len(arr)
    result = [None] * n

    for i in arr.index:
        tmp = ord(arr[i][0])-65
        if tmp == 25:
            tmp = 24
        if arr[i][1] == '2':
            tmp += 25
        if i%2 == 1:
            tmp = tmp + 50
        if tmp < 10:
            if tmp < 1:
                tmp = str(0) + str(0) + str(tmp)
            else:
                tmp = str(0) + str(tmp)
        else:
            tmp = str(tmp)
        P = ''
        for j in range(len(arr[i])-1):
            if j < 2:
                P = P + P.join(tmp[j])
                continue
            P = P + P.join(arr[i][j])
        result[i] = P
    return result

def check_upsidedown(arr, check):
    n = len(arr)
    result = [None] * n

    for i in arr.index:
        if (int(check[i][0:2]) >= 50) and (i%2 == 0):
            result[i] = arr[i][1] + arr[i][0] + arr[i][2:]
        elif (int(check[i][0:2]) < 50) and (i%2 == 1):
            result[i] = arr[i][1] + arr[i][0] + arr[i][2:]
        else:
            result[i] = arr[i]
    return result

def count_check_code(arr):
    n = len(arr)
    result = [None] * n

    for i in arr.index:
        tmp_num = 0
        head = arr[i][0]
        if head == 'A':
            tmp_num = 10
        elif head == 'B':
            tmp_num = 11
        elif head == 'C':
            tmp_num = 12
        elif head == 'D':
            tmp_num = 13
        elif head == 'E':
            tmp_num = 14
        elif head == 'F':
            tmp_num = 15
        elif head == 'G':
            tmp_num = 16
        elif head == 'H':
            tmp_num = 17
        elif head == 'I':
            tmp_num = 34
        elif head == 'J':
            tmp_num = 18
        elif head == 'K':
            tmp_num = 19
        elif head == 'L':
            tmp_num = 20
        elif head == 'M':
            tmp_num = 21
        elif head == 'N':
            tmp_num = 22
        elif head == 'O':
            tmp_num = 35
        elif head == 'P':
            tmp_num = 23
        elif head == 'Q':
            tmp_num = 24
        elif head == 'R':
            tmp_num = 25
        elif head == 'S':
            tmp_num = 26
        elif head == 'T':
            tmp_num = 27
        elif head == 'U':
            tmp_num = 28
        elif head == 'V':
            tmp_num = 29
        elif head == 'W':
            tmp_num = 32
        elif head == 'X':
            tmp_num = 30
        elif head == 'Z':
            tmp_num = 33
        tmp = str(tmp_num)+arr[i][1:]
        check_code = int(tmp[0])
        for j in range(1, len(tmp)):
            check_code = check_code + int(int(tmp[j])*(len(tmp)-j))
        check_code = 10 - (check_code%10)
        result[i] = arr[i] + str(check_code%10)
    return result

def main():
    ID = ["A231217403", "A123456789"]
    plaintext = IDN_to_number(ID)
    for i in plaintext:
        tweak = generate_tweak(i)
        Encrypted_num = FF1(i,10,key,tweak)
        Encrypted_ID = number_to_IDN(Encrypted_num)
        Decrypted_num = FF1_decrypt(Encrypted_num,10,key,tweak)
        Decrypted_ID = number_to_IDN(Decrypted_num)
        print(Encrypted_num, Encrypted_ID, Decrypted_num, Decrypted_ID)


if __name__ == "__main__":
    main()